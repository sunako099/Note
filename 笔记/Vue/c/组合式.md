# setup函数

## 参数

◼ 我们先来研究一个setup函数的参数，它主要**有两个参数**：

​		 第一个参数：props

​		 第二个参数：context

◼ props非常好理解，它其实就是**父组件传递过来的属性**会被**放到props对象**中，我们在**setup中如果需要使用**，那么就可以直接**通过props参数获取：**

​		 对于定义props的类型，我们还是和之前的规则是一样的，在props选项中定义；

​		 并且在template中依然是可以正常去使用props中的属性，比如message；

​		 如果我们在setup函数中想要使用props，那么**不可以通过 this 去获取**（后面我会讲到为什么）；

​		 因为props有直接作为参数传递到setup函数中，所以我们可以直接通过参数来使用即可；

◼ 另外一个参数是context，我们也称之为是一个**SetupContext**，它里面**包含三个属性**：

​		 **attrs**：所有的非prop的attribute；

​		 **slots**：父组件传递过来的插槽（这个在以渲染函数返回时会有作用，后面会讲到）；

​		 **emit**：当我们组件内部需要发出事件时会用到emit（因为我们不能访问this，所以不可以通过 this.$emit发出事件）；

## 返回值

◼ setup既然是一个函数，那么它也可以有**返回值**，**它的返回值用来做什么呢？**

​		 setup的返回值可以在模板template中被使用；

​		 也就是说我们可以通过setup的返回值来替代data选项；

◼ 甚至是我们可以**返回一个执行函数**来**代替在methods中定义的方法**：

```js
cost name="cose"
let counter=10
const ince=()=>{
    counter++
}
return {
    name,
    counter,
    ince
}
```

◼ 但是，如果我们将 counter 在 increment 或者 decrement进行操作时，**是否可以实现界面的响应式呢？**

​		 答案是不可以；

​		 这是因为**对于一个定义的变量来说，默认情况下，Vue并不会跟踪它的变化，来引起界面的响应式操作**；

# **Reactive API**

◼ 如果想为在setup中定义的数据提供响应式的特性，那么我们可以**使用reactive的函数**：

```js
const state=reactive({
    name:"cods"
})
```

◼ **那么这是什么原因呢？为什么就可以变成响应式的呢？**

​		 这是因为当我们**使用reactive函数处理我们的数据之后，数据再次被使用时就会进行依赖收集**；

​		 当**数据发生改变**时，所有**收集到的依赖都是进行对应的响应式操作**（比如更新界面）；

​		 事实上，我们编写的**data选项**，也是**在内部交给了reactive函数将其编程响应式对象的**；

◼ reactive API对**传入的类型是有限制的**，它要求我们必须传入的是**一个对象或者数组类型**：

​		 如果我们传入一个基本数据类型（String、Number、Boolean）会报一个警告；

# **Ref API**

 ref 会返回一个可变的响应式对象，该对象作为一个 **响应式的引用** 维护着它内部的值，这就是ref名称的来源；

 它内部的值是在ref的 value 属性中被维护的；

`const message=ref("Hello World")`

◼ **这里有两个注意事项：**

​		 在**模板中**引入ref的值时，Vue**会自动帮助我们进行解包操作**，所以我们并不需要在模板中通过 ref.value 的方式来使用；

​		 但是**在 setup 函数内部**，它依然是一个 ref引用， 所以对其进行操作时，我们依然**需要使用 ref.value**的方式；